0612

클래스 => 객체

의자를 구매
의자만드는 설명서 = 클래스
설명서를 이용해서 만든 빨간색의자 = 객체
                              파랑색의자 = 객체
클래스 = 다양한 데이커타입을 가지고 있을수있음
클래스 이름의 첫글자는 대문자
클래스 이름은 명사
여러개의 단어가 합쳐지면 두번째 단어의 첫글자 대문자

Animal 클래스
cat 객체

cat객체는 Animal클래스의 인스턴스

cat은 객체다


cat은 Animal의 인스턴스



접근제한자 리턴타입 메서드이름(매개변수) {
	메서드 기능 구현
}

public void


0613


169p

static변수
동일한 클래스의 모든 객체를 공유하는 변수임
그래서 사용하는 것도 객체이름.변수 형태로 사용도 가능하지만
클래스이름.변수 형태로 사용할 수 있다.
클래스이름.변수로 사용 가능하다는 소리는
객체 생성을 안해도 사용할 수 있다는 소리가 된다.


메서드
public 리턴타입 메서드이름( ) {
	실행 코드
}

public 리턴타입 메서드이름(매개변수) {
	실행 코드
}

public 리턴타입 메서드이름(매개변수,매개변수) {
	실행 코드
}

메서드 오버로딩
동일한 이름을 가진 메서드를 생성할 수 있다.
매개변수의 데이터 타입이나 개수가 달라야 한다.


0614

this
s객체를 생성
메인에서 이름,나이를 입력
이름과, 나이를 멤버변수에 저장하는 메서드


p185
Call By Value : 내용에 의한 참조
Call By Reference : 주소에 의한 참조



0615

static 메서드(오버라이딩 x,오버라이딩 : 메서드 재정의)
클래스이름.메서드이름()
클래스의 모든 인스턴스들이 메모리를 공유
인스턴스변수, 메서드 사용 못함

인스턴스 메서드
객체이름.메서드이름()
클래스의 모든 인스턴스들이 각각 따로 할당


오버로딩 192p.


생성자 195p.
생성자 이름은 클래스이름과 동일
리턴타입 X


0616

VO

Product
Value Object


0621

222p. 상속
부모 클래스가 자식클래스한테 상속
223p.

전자제품
전원

TV	컴퓨터	냉장고	전자레인지	에어컨
채널	인터넷	냉동	타이머		온도


227p.단일 상속

학생
이름,성별,학번

고등학생			대학생
이름,성별,학생		이름,성별,학생
교복여부			학점
성적

직장인(직원)  extends 고등학생,대학생
직장인.이름 = "ㅁㅁㅁ"



0622


232p.	super()
	=> 부모클래스의 기본생성자 호출
	메모리 어딘가에 String name, int age가진 객체가 생성됨
	위에서 생성된 객체를 자식클래스가 상속받음
	상속받았으므로 자식 클래스에는 name, age 있음
	name,age,gender 매개변수값을 설정
	설정된 멤버변수 형태로 객체가 생성됨


	super(name, age)
	=> 매개변수로 받은 name,age를 넣어준 객체 생성
	this


final, static메서드



229p. 오버라이딩 - 메서드 재정의
오버로딩
-동일 클래스에서 같은 이름을 가진 메서드
-매개변수가 다름
오버라이딩
-상속을 받은 부모/자식 클래스에 같은 이름을 가진 메서드
(리턴타입,매개변수도 동일)
-처리하는 코드가 다름



클래스, 멤버 변수, 생상자, 메서드

캠슐화 - 정보 은닉


접근 제어자 243p.
public : 어디서나 접근 가능
private : 동일 클래스에서만 접근 가능(클래스 X)
default : 동일 패키지에서 접근 가능 , 아무것도 안쓰면 default임
protected : 동일 패키지, 자식 클래스(클래스 X)



0623

244p. 캡슐화
상속
캡슐화 - 객체의 상태랑 동작을 묶어서 관리함
다형성
추상화

접근 제어 : 멤버변수를 private 설정
              외부에서 접근을 못하도록 제한
	수정, 접근을 하도록 메서드로 구현
	( 제한된 방법으로 사용 )
	잘못된 조작을 방지
정보 은닉 : 데이터(멤버 변수) 숨김


246p. 다형성
업캐스팅 : 자식객체가 부모객체로 형변환( 자동 형변환 )
다운캐스팅 : 업캐스팅된 부모가 자식객체로 형변환 (명시적 형변환)




0626
싱글톤(Singleton)
객체는 하나
전역으로 접근 가능

Test 클래스
Test t1 = new Test();
Test t2 = new Test();

추상화 257p.
추상 클래스
public abstract class 클래스이름 {
}
추상 클래스는 객체 생성 못함
추상 메서드 ( 구현부가 없는 메서드)



인터페이스 263p.

xxx interface 인터페이스이름 {

}


0627
-날짜 시간 366p.
Calendar 클래스, Date 클래스

-컬렉션 프레임워크 389p.
List : 순서가 있음, 데이터 중복 허용
     ( ArrayList, Vector, LinkedList, Stack, Queue )
Set : 순서가 없음, 데이터 중복 불가
     ( HashSet, TreeSet)
Map : key와 value 한쌍으로 이루어진 데이터의 집합
        key는 중복 불가, value는 중복 가능
        순서 없음	
       ( HashMap, TreeMap, Hashtable, Properties )






List
크기가 고정되어있지 않음 (동적 할당)

ArrayList 394p.

ArrayList => [5,10,20,3];

for(변수 선연  : 컬렉션변수명) {
  // 컬렉션 크기만큼 알아서 반복함
}


0628
Iterator 411p.
List, Set, Map

boolean hasNext() : Iterator에 다음 요소가 있으면 T
??? next() : 다음 요소를 리턴시켜줌
void remove() : 최근 반환한 요소를 삭제

Set 424p.
순서가 없음
중복 불가능

TreeSet 429p.
검색기능 강화

Map 436p.
key와 value 한쌍으로 저장
key는 중복 불가능, value 상관 없음
map에 key들을 set으로 리턴
[둘리, 홍길동, ㅁㅁㅁ, 고길동]



0630
Iterator
컬렉션에 정보를 얻음
컬렉션을 다룰 떄 각 컬렉션별 데이터를 가져오는 방
식이 전부 다름
iterator이용하면 동일한 방식으로 접근 가능
List 순서가 있음 get(인덱스)
Set 순서가 없음 -> 향상된 for
map 순서가 없음(key, value) -> get(key)

hasNext( ) : 다음 데이터가 있냐 없냐를 리턴
next( ) : 다음 데이터를 리턴( 위치도 다음으로 이동)
remove( ) : 데이터 삭제
	   최근 리턴한 데이터를 삭제
	   next( ) 호출 후 사용



0703
enum(열거형) - 475p.
상수들의 집합
제한된 집합
enum Weekday {
월요일,
화요일,
수요일,
}

어노테이션 481p.
@Override

Thread 쓰레드 506p.




0705
함수형 인터페이스 - 560p.
Supplier -> 매개변수가 없음, 리턴 제네릭으로 설정
BiConsumer -> 매개변수 1개, 리턴 없음
BiPredicate -> 매개변수 1개 -> 리턴 boolean
BiFunction -> 매개변수 1개, 리컨도 제네릭으로 설정

메서드 참조 - 566p.

스트림 - 568p.
filter : 조건에 만족하는것만 리턴
filter( Predicate<T> p )
map : 데이터를 반환해서 새로운 스트림으로 생성
sorted : 정렬
flatMap : 평면화된 스트림을 생성

line.split("   +")

aaaa b c d

.get

.isPresent( )



0706
입출력 스트림 624p.
Stack -> LIFO
Queue -> FIFO - IO스트림
close( )
flush( )
